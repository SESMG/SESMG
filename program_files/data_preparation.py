import osfrom sklearn.preprocessing import StandardScalerfrom sklearn.cluster import KMeansimport pandas as pdimport numpy as npfrom itertools import cycle, isliceimport matplotlib.pyplot as pltfrom pandas.plotting import parallel_coordinatesdef extract_single_days(data_set, column_name):    ''' Extracts individual days of a certain column of a weather data set as    lists. Caution: weather data set must be available in hourly resolution!    Parameters    ----------    data_set: weather data set to be extractet    column_name: column name of which the extraction should be applied    Returns    -------    cluster_vectors: list, containing a list/vector for every single day    '''    # extract data_set of cluster_criterion    cluster_df = data_set[column_name]    # extract single days as lists and add them to a list    cluster_vectors = []    for i in range(0, int(len(cluster_df) / 24)):        cluster_vector = []        for j in range(24):            cluster_vector.append(cluster_df[i * 24 + j])        cluster_vectors.append(cluster_vector)    # returns the list with extractet day datasets    return cluster_vectorsdef calculate_k_means_clusters(cluster_number, weather_data, cluster_criterion):    ''' Applies the k-means algorithm to a list of day-weather-vectors.    Caution: weather data set must be available in hourly resolution!    Parameters    ----------    cluster_number: Number of k-mean-clusters    weather_data: weather_data, the clusters should be applied to    cluster_criterion: weather_parameter/column name which should be applied as                       cluster criterion    Returns    -------    model.labels_: Chronological list, which days of the weather data set belongs to which cluster    '''    cluster_vectors = extract_single_days(data_set=weather_data, column_name=cluster_criterion)    kmeans = KMeans(n_clusters=cluster_number)    model = kmeans.fit(cluster_vectors)    return model.labels_def calculate_cluster_means(data_set, cluster_number, cluster_labels):    '''Determines weather averages of the individual clusters for a weather    dataset, based on predetermined cluster allocation. Caution: weather data    set must be available in hourly resolution!    Parameters    ----------    data_set: data_set, the clusters should be applied to    cluster_number: Number of clusters    cluster_labels: Chronological list, which days of the weather data set belongs to which cluster    Returns    -------    prep_data_set: pandas dataframe containing the prepared weather data                       set    '''    column_names = [data_set.columns[i] for i in                    range(1, len(data_set.columns))]    # Define pandas Dataframe for final data_setset    prep_data_set = pd.DataFrame()    # Loop for every column of the weather data set    for i in range(len(column_names) - 1):        # Extract individual weather data set for the current weather data column        data_set_column = extract_single_days(data_set=data_set, column_name=column_names[i])        # Define empty list used later        reference_data_set = []        # Loop for every cluster        for j in range(0, cluster_number):  # Für jedes k-Means Cluster            # Define empty list used later            cluster_dataset = []            # Loop for every day of the weather data set            for k in range(len(data_set_column)):                # if the day belongs to the current cluster, it will be appended to 'cluster_dataset'                if cluster_labels[k] == j:                    cluster_dataset.append(data_set_column[k])            # Calculates the mean for ever hour of the current cluster            cluster_dataset_array = np.array(cluster_dataset)            # Appends the calculated mean values to the 'reference_data_set' list            reference_data_set = reference_data_set + cluster_dataset_array.mean(                axis=0).tolist()        # Appends the calculated reference days for the curent weather data collumn to the final weather data set        prep_data_set[column_names[i]] = reference_data_set    return prep_data_setdef k_means_parameter_adaption(nodes_data, clusters, cluster_labels):    '''    To be able to work with the adapted weather data set some parameters from    nodes_data must be changed.    Parameters    ----------    nodes_data: system parameters    k_mean_parameters: k-means-clustering parameters (dictionary)    Returns    -------    '''    # Addapting variable costs    variable_cost_factor = int(int(nodes_data['energysystem']['periods']) / int(24*clusters))    nodes_data['sources']['variable costs /(CU/kWh)'] = nodes_data['sources']['variable costs /(CU/kWh)']*variable_cost_factor    nodes_data['buses']['excess costs /(CU/kWh)'] = nodes_data['buses']['excess costs /(CU/kWh)'] * variable_cost_factor    nodes_data['buses']['shortage costs /(CU/kWh)'] = nodes_data['buses']['shortage costs /(CU/kWh)'] * variable_cost_factor    nodes_data['transformers']['variable input costs /(CU/kWh)'] = nodes_data['transformers']['variable input costs /(CU/kWh)'] * variable_cost_factor    nodes_data['transformers']['variable output costs /(CU/kWh)'] = nodes_data['transformers']['variable output costs /(CU/kWh)'] * variable_cost_factor    nodes_data['transformers']['variable output costs 2 /(CU/kWh)'] = nodes_data['transformers']['variable output costs 2 /(CU/kWh)'] * variable_cost_factor    nodes_data['storages']['variable input costs'] = nodes_data['storages']['variable input costs'] * variable_cost_factor    nodes_data['storages']['variable output costs'] = nodes_data['storages']['variable output costs'] * variable_cost_factor    nodes_data['demand']['annual demand /(kWh/a)'] = nodes_data['demand']['annual demand /(kWh/a)'] / variable_cost_factor    #nodes_data['demand']['nominal value /(kW)'] = nodes_data['demand']['nominal value /(kW)'] / variable_cost_factor    # Addapting timesystem parameters    nodes_data['energysystem']['end date'] = nodes_data['energysystem']['start date'] + pd.Timedelta(str(clusters*24-1)+' hours')    nodes_data['energysystem']['periods'] = int(24*clusters)def k_means_timeseries_adaption(nodes_data, clusters, cluster_labels):    prep_timeseries = calculate_cluster_means(data_set = nodes_data['timeseries'],                                              cluster_number = clusters,                                              cluster_labels = cluster_labels)    # Rename columns of the new timeseries-dataset    prep_timeseries['timestamp'] = nodes_data['timeseries']['timestamp'][:int(len(nodes_data['timeseries']) / clusters)]    # prep_timeseries.set_index('timestamp', inplace=True)    nodes_data['timeseries'] = prep_timeseriesdef k_means_algorithm(clusters, criterion, nodes_data):    weather_data = nodes_data['weather data']    # Calculate k-mean clusters, based on the cluster_criterion    cluster_labels = calculate_k_means_clusters(cluster_number= clusters,                                                weather_data= weather_data,                                                cluster_criterion=criterion)    # Apply the Clusters to the entire weather_dataset    prep_weather_data = calculate_cluster_means(data_set = weather_data,                                                cluster_number = clusters,                                                cluster_labels = cluster_labels)    print(prep_weather_data)    # Rename columns of the new weather_dataset    prep_weather_data['timestamp'] = weather_data['Unnamed: 0'][:len(prep_weather_data)]    prep_weather_data.set_index('timestamp', inplace=True)    print(prep_weather_data)    # Replaces the weather data set in nodes_data by the new one    nodes_data['weather data'] = prep_weather_data    # Adapts Other Parameters (despite weatherdata) of the energy system    k_means_parameter_adaption(nodes_data, clusters, cluster_labels)    k_means_timeseries_adaption(nodes_data, clusters, cluster_labels)def timeseries_averaging(clusters, nodes_data):    weather_data = nodes_data['weather data']    # # Calculate k-mean clusters, based on the cluster_criterion    # cluster_labels = calculate_k_means_clusters(cluster_number= clusters,    #                                             weather_data= weather_data,    #                                             cluster_criterion=criterion)    days = int(len(weather_data) / 24)    cluster_labels = []    for i in range(clusters):        for j in range(days // clusters):            cluster_labels.append(i)    if days % clusters >= 0:        for k in range(days % clusters):            cluster_labels.append(clusters - 1)    cluster_labels = np.array(cluster_labels)    # Apply the Clusters to the entire weather_dataset    prep_weather_data = calculate_cluster_means(data_set = weather_data,                                                cluster_number = clusters,                                                cluster_labels = cluster_labels)    print(prep_weather_data)    # Rename columns of the new weather_dataset    prep_weather_data['timestamp'] = weather_data['Unnamed: 0'][:len(prep_weather_data)]    prep_weather_data.set_index('timestamp', inplace=True)    print(prep_weather_data)    # Replaces the weather data set in nodes_data by the new one    nodes_data['weather data'] = prep_weather_data    # Adapts Other Parameters (despite weatherdata) of the energy system    k_means_parameter_adaption(nodes_data, clusters, cluster_labels)    k_means_timeseries_adaption(nodes_data, clusters, cluster_labels)def data_set_slicing(n_days, data_set):    column_names = [data_set.columns[i] for i in                    range(1, len(data_set.columns))]    prep_data_set = pd.DataFrame()    # Loop for every column of the weather data set    for i in range(len(column_names)):        # Extract individual weather data set for the current weather data column        data_set_column = extract_single_days(data_set=data_set, column_name=column_names[i])        # Falls der Datensatz nicht durch die entsprechende Tagesanzahl teilbar ist, wird        # der Datensatz entsprechend gekürzt        if len(data_set_column)%n_days > 0:            data_set_column = data_set_column[0:-(len(data_set_column)%n_days)]        sliced_column = data_set_column[0::n_days]        reference_data_set = []        for j in range(len(sliced_column)):            reference_data_set = reference_data_set + sliced_column[j]        # Appends the calculated reference days for the curent weather data collumn to the final weather data set        prep_data_set[column_names[i]] = reference_data_set    return prep_data_setdef timeseries_slicing(n_days, nodes_data):    weather_data=nodes_data['weather data']    data_set = nodes_data['weather data']    print(weather_data)    prep_weather_data = data_set_slicing(n_days, data_set=data_set)    # Rename columns of the new weather_dataset    prep_weather_data['timestamp'] = weather_data['Unnamed: 0'][:len(prep_weather_data)]#:int(len(prep_weather_data))]    prep_weather_data.set_index('timestamp', inplace=True)    print(prep_weather_data)    # Replaces the weather data set in nodes_data by the new one    nodes_data['weather data'] = prep_weather_data    #    # # Adapts Other Parameters (despite weatherdata) of the energy system    k_means_parameter_adaption(nodes_data=nodes_data,                               clusters=365//n_days, #todo: relativen wert einfügen!                               cluster_labels=0)    prep_timeseries = data_set_slicing(n_days, data_set=nodes_data['timeseries'])    prep_timeseries['timestamp'] = nodes_data['timeseries']['timestamp'][:len(prep_weather_data)]    # prep_timeseries.set_index('timestamp', inplace=True)    nodes_data['timeseries'] = prep_timeseries    print(prep_timeseries)def timeseries_downsampling(nodes_data, n_timesteps):    # weather_data = nodes_data['weather data']    # # downsampling_data = weather_data[::n_timestaps]    # downsampling_data = weather_data.iloc[::n_timesteps, :]    # # downsampling_data.reset_index(drop=True)    # # print(downsampling_data)    # # downsampling_data['timestamp'] = weather_data['Unnamed: 0'][:len(downsampling_data)]    # # downsampling_data.set_index('timestamp', inplace=True)    # print(downsampling_data)    nodes_data['energysystem']['temporal resolution'] = str(n_timesteps)+nodes_data['energysystem']['temporal resolution']    nodes_data['energysystem']['periods'] = int(nodes_data['energysystem']['periods']/n_timesteps)